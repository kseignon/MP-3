---
title: "Test_code"
author: "Julia Portocarrero"
output: html_document
---
```{r}
library(sf)
library(dplyr)
# devtools::install_github("beanumber/macleish")
#install.packages("macleish")
library(macleish)
library(tidyverse)
library(leaflet)
```

```{r}
test_trail <- st_as_sf(macleish_layers[["trails"]])
#trails2 <- st_set_geometry(macleish_layers[["trails"]], NULL)
```

Using: http://adamwilson.us/RDataScience/04_Spatial_with_sf.html

Try filtering by length
```{r}
trails <- test_trail %>%
  mutate(length = st_length(geometry))
```

#### Work so far on MP#:

Find length:
```{r}
trails <- st_as_sf(macleish_layers[["trails"]]) %>% 
  mutate(computed_length = st_length(geometry))

trails_4326 <- trails %>%
  st_transform(4326)
trails_4326
```

Get contour data:
```{r}
url <- "http://download.massgis.digital.mass.gov/shapefiles/state/contours250k.zip"
local_file <- basename(url)
download.file(url, destfile = local_file)
unzip(local_file, exdir = "contours")

library(sf)
dsn <- path.expand("contours")

st_layers(dsn)
contours_elevation <- read_sf(dsn)
names (contours_elevation)
```

Check crs and projections:
```{r}
st_crs(contours_elevation)
contours_4326 <- st_transform(contours_elevation, 4326)
st_crs(contours_4326)
```

Restrict contours to macleish and plot with all trails:
```{r}
Boundary_contours[[1]] <- st_intersection(st_as_sf(macleish_layers[["boundary"]]), contours_4326)

leaflet() %>%
  addTiles() %>%
  addPolylines(data = macleish_layers[["boundary"]])%>%
  addPolylines(data = Boundary_contours) %>%
  addPolylines(data = macleish_layers[["trails"]], color= "brown")
```

Test with just "Porcupine Trail"
```{r}
porcupine <- st_as_sf(macleish_layers[["trails"]]) %>%
  filter(name == "Porcupine Trail") %>%
  mutate(computed_length = st_length(geometry)) 

leaflet() %>%
  addTiles() %>%
  addPolylines(data = macleish_layers[["boundary"]])%>%
  addPolylines(data = Boundary_contours) %>%
  addPolylines(data = porcupine, color= "brown")

st_intersection(porcupine, Boundary_contours) %>%
  group_by(name) %>%
  summarise(min = min(CONTOUR_FT), max = max(CONTOUR_FT), length = computed_length)
```


Function to make df for all trails, that has min and max:
```{r, warning=FALSE}
#function to take plot all trails
trail_data_fun <- function(data1, trail_name) {
  
  #filter the trail data
  trail_data <- st_as_sf(data1) %>%
  filter(name == trail_name) %>%
  #group_by(name) %>%
  mutate(computed_length = st_length(geometry))
  
  #intersect with contour data
  new_df <- st_intersection(trail_data, Boundary_contours) %>%
  group_by(name) %>%
  summarise(min = min(CONTOUR_FT), max = max(CONTOUR_FT), length = sum(computed_length), change = max-min)

  return(new_df)
}

trail_names <- c("Porcupine Trail", "Western Loop", "Poplar Hill Road", "Vernal Pool Loop", "Eastern Loop", "entry trail", "Easy Out", "Snowmobile Trail", "Driveway")

#these are the trails that actually intersect with the contour data:
trail_int_names <- c("Snowmobile Trail", "Eastern Loop", "Vernal Pool Loop", "Poplar Hill Road", "Western Loop", "Porcupine Trail") 

#test function
trail_data_fun(macleish_layers[["trails"]], "Porcupine Trail")

#try with all trails:
trail_df_list <- lapply(data1 = macleish_layers[["trails"]], trail_int_names, trail_data_fun)

#merge list of df into one df
trail_df_sf <-  do.call("rbind", trail_df_list) 

#convert Multipoints to linestring for leaflet plotting
trail_df_sf2 <- as.data.frame(trail_df_sf) #makes data.frame
trail_df_sf3 <- st_sf(trail_df_sf2) #makes sf
trail_df_sf4 <- st_cast(trail_df_sf3, "LINESTRING") #change points to linestring

```

Categorize each row
```{r}
#error: reading variable "change" as a list with 2 values

#!grep(change, "\[.\]") #this extracts only the value
#stringr::regmatches(change, !regexpr("\[.\]", change))
#test %>%
  #value <- regmatches(test$change, "\\[.\\]", invert = TRUE)
#for now, only try with first row
test <- head(trail_df_sf4, 1)
  if (test$change < 1) {
    mutate(test, category = "easy")
  } else if (test$change > 1000) {
    mutate(test, category = "hard")
  } else {
    mutate(test, category = "medium")
  }

#(test$change < 100 | as.numeric(test$length) > 20)

classify_fun <- function(data1) {
  data2 <- if (data1$change < 1) {
    mutate(data1, category = "easy")
  } else if (data1$change > 1000) {
    mutate(data1, category = "hard")
  } else {
    mutate(data1, category = "medium")
  }
return(data2)  
}

classify_fun(test)
trail_df_sf1 <- lapply(trail_df_list, classify_fun)

#merge list of df into one df
trail_df_sf <-  do.call("rbind", trail_df_sf1) 

#convert Multipoints to linestring for leaflet plotting
trail_df_sf2 <- as.data.frame(trail_df_sf) #makes data.frame
trail_df_sf3 <- st_sf(trail_df_sf2) #makes sf
trail_df_sf4 <- st_cast(trail_df_sf3, "LINESTRING") #change points to linestring

```

Categorize each trail and plot:
```{r, eval = FALSE}
trail_names <- c("Porcupine Trail", "Western Loop", "Poplar Hill Road", "Vernal Pool Loop", "Eastern Loop", "entry trail", "Easy Out", "Snowmobile Trail", "Driveway")
classification <- c("Easy", "Hard", "Hard", "Hard", "Medium", "Medium", "Easy", "Easy", "Hard", "Easy")

trails_classified <- merge(trail_names, classification) 
names(trails_classified)[1] <- "name" #rename column for join
trails_final <- inner_join(macleish_layers[["trails"]], trails_classified, by = "name") #for some reason I get so many rows...

#change data frame to spatial
#as_Spatial(trails_final)
#xy <- trails_final[,c(1,2)]
#SpatialPointsDataFrame(coords = xy, data = trails_final,
                              # proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))

leaflet() %>%
  addTiles() %>%
  addPolylines(data = macleish_layers[["boundary"]])%>%
  addPolylines(data = Boundary_contours)# %>%
  #addPolylines(data = trails_final, color= "brown")
```


Try with colors: Error
```{r}
library(colorspace)

factpal <- colorFactor((rainbow_hcl(n = 9, c = 50, l = 70, start = 1, end = 320)), trails$name, TRUE)

#factpal2 <- colorFactor(palette = c("red", "blue", "orange", "grey", "white"), domain = trail_df_sf2)

leaflet() %>%
 addTiles() %>%
 addPolylines(data = macleish_layers[["boundary"]])%>%
 addPolylines(data = Boundary_contours) %>%
 addPolylines(data = trail_df_sf4, color= ~factpal(name))
```


